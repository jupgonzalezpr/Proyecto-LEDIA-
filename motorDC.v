// Code generated by Icestudio 0.5.0
// Thu, 02 Sep 2021 20:55:22 GMT

`default_nettype none

module main (
 input v463092,
 input vb5e0f9,
 output ve9e5a8
);
 wire w0;
 wire w1;
 wire [0:3] w2;
 wire w3;
 wire w4;
 assign w1 = v463092;
 assign w3 = vb5e0f9;
 assign ve9e5a8 = w4;
 ve4e198 vffe139 (
  .v8d0ca6(w0),
  .vbf084f(w2),
  .vc03fca(w3),
  .vdec06b(w4)
 );
 v0e64bc v6e2d3e (
  .v8337bc(w0),
  .v531e20(w1)
 );
 ve5f490 v035454 (
  .va50a91(w2)
 );
endmodule

module ve4e198 #(
 parameter v103dea = 0
) (
 input v8d0ca6,
 input [3:0] vbf084f,
 input vc03fca,
 output vdec06b
);
 localparam p4 = v103dea;
 wire w0;
 wire [0:3] w1;
 wire w2;
 wire w3;
 assign w0 = v8d0ca6;
 assign w1 = vbf084f;
 assign w2 = vc03fca;
 assign vdec06b = w3;
 ve4e198_vfd72d5 #(
  .P(p4)
 ) vfd72d5 (
  .clk(w0),
  .w(w1),
  .write(w2),
  .pwm(w3)
 );
endmodule

module ve4e198_vfd72d5 #(
 parameter P = 0
) (
 input clk,
 input [3:0] w,
 input write,
 output pwm
);
 //-- Parámetro P: Número de bits del prescaler
 //-- (P = 0 para no usar prescaler)
 
 //-- Bits para el nivel
 localparam N = 4;
 
 //-- Contador principal
 //-- Tamaño: Bits anchura + Prescaler (P)
 localparam C = N + P;
 
 reg [C-1:0] counter = 0;
 always @(posedge clk)
   counter <= counter + 1;
 
 //-- Detectar el comienzo de un ciclo nuevo:
 //-- cuando hay un flanco de bajada en el bit de  
 //-- mayor peso (C-1)
 
 reg q = 0;
 always @(posedge clk)
   q <= counter[C-1];
  
 //-- Cuando cycle_begin es 1, indica que comienza
 //-- un nuevo ciclo
 wire cycle_begin = q & ~counter[C-1];
   
 //-- Registro W: Almacena la anchura actual
 reg [N-1:0] reg_w = 0;
 
 always @(posedge clk)
   //-- Se carga en cada nuevo ciclo de pwm
   if (cycle_begin)
     reg_w <= reg_buf;
 
 //-- Registro buffer. Es donde se almacena la anchura
 //-- introducida por el usuario mientras llega un  
 //-- nuevo ciclo de pwm, y se pueda cargar en el  
 //-- registro w
 reg [N-1:0] reg_buf = 0;
 
 always @(posedge clk)
   //-- Se actualiza cuando llega un dato nuevo
   if (write)
     reg_buf <= w;
 
 //-- Salida del pwm: comparador
 wire pwm_t = (counter[C-1:C-N] < w);
 
 reg pwm = 0;
 //-- Registrar la salida del pwm
 always @(posedge clk)
   pwm <= pwm_t;
 
 
endmodule

module v0e64bc #(
 parameter v207e0d = 1500
) (
 input v531e20,
 output v8337bc
);
 localparam p2 = v207e0d;
 wire w0;
 wire w1;
 assign v8337bc = w0;
 assign w1 = v531e20;
 v0e64bc_v94c6d7 #(
  .HZ(p2)
 ) v94c6d7 (
  .clk_o(w0),
  .clk(w1)
 );
endmodule

module v0e64bc_v94c6d7 #(
 parameter HZ = 0
) (
 input clk,
 output clk_o
);
 
 //parameter HZ=1500;
 
 //-- Constante para dividir y obtener una frecuencia de 8 kHz
 localparam M = 12000000/HZ;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 //-- Temporal clock
 reg clk_t = 0;
 
 //-- Se usa un contador modulo M/2 para luego
 //-- pasarlo por un biestable T y dividir la frecuencia
 //-- entre 2, para que el ciclo de trabajo sea del 50%
 always @(posedge clk)
     if (divcounter == M/2) begin
       clk_t <= 1;
       divcounter = 0;
     end 
     else begin
       divcounter <=  divcounter + 1;
       clk_t = 0;
     end 
   
 reg clk_o = 0;  
     
 //-- Biestable T para obtener ciclo de trabajo del 50%
 always @(posedge clk)
   if (clk_t)
     clk_o <= ~clk_o;
 
endmodule

module ve5f490 #(
 parameter vfffc23 = 5
) (
 output [3:0] va50a91
);
 localparam p0 = vfffc23;
 wire [0:3] w1;
 assign va50a91 = w1;
 v9274d3 #(
  .vc5c8ea(p0)
 ) v8800c6 (
  .v00a92d(w1)
 );
endmodule

module v9274d3 #(
 parameter vc5c8ea = 0
) (
 output [3:0] v00a92d
);
 localparam p1 = vc5c8ea;
 wire [0:3] w0;
 assign v00a92d = w0;
 v9274d3_v465065 #(
  .VALUE(p1)
 ) v465065 (
  .k(w0)
 );
endmodule

module v9274d3_v465065 #(
 parameter VALUE = 0
) (
 output [3:0] k
);
 assign k = VALUE;
endmodule
